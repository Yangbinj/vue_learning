<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>base promise</title>
    <script src="https://cdn.bootcss.com/jquery/3.5.1/jquery.js"></script>
</head>

<body>
    <div></div>
    <!-- <script src="js/jquery-3.2.1.js"></script> -->
    <script>
        // resolve作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
        // reject作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
        // promise有三个状态：
        // 1、pending[待定]初始状态
        // 2、fulfilled[实现]操作成功
        // 3、rejected[被否决]操作失败
        // 当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；
        // promise状态一经改变，不会再变。
        // Promise对象的状态改变，只有两种可能：
        // 从pending变为fulfilled
        // 从pending变为rejected。
        // 这两种情况只要发生，状态就凝固了，不会再变了。
        // 链接：https://www.jianshu.com/p/1b63a13c2701
        new Promise(
            function (resolve, reject) {
                // 一段耗时的异步操作
                resolve('成功') // 数据处理完成
                // reject('失败') // 数据处理出错
            }
        ).then(
            (res) => { console.log(res, 'dd') },  // 成功
            (err) => { console.log(err) } // 失败
        )
        new Promise(
            resolve => {
                setTimeout(() => {
                    resolve('hello')
                }, 2000)
            },
            reject => {
                reject('fail');
            }).then(res => {
                console.log(res)
            }, err => {
                console.log(err);
            })
        new Promise(resolve => {
            setTimeout(() => {
                resolve('hello')
            }, 2000)
        }).then(val => {
            console.log(val) //  参数val = 'hello'
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve('world')
                }, 2000)
            })
        }).then(val => {
            console.log(val) // 参数val = 'world'
        })

        let promise = new Promise(function (resolve, reject) {
            console.log('Promise');
            resolve();
        });

        //promise 结合ajax
        const getJSON = function (url) {
            const promise = new Promise(function (resolve, reject) {
                const handler = function () {
                    if (this.readyState !== 4) {
                        return;
                    }
                    if (this.status === 200) {
                        resolve(this.response);
                    } else {
                        reject(new Error(this.statusText));
                    }
                };
                const client = new XMLHttpRequest();
                client.open("GET", url);
                client.onreadystatechange = handler;
                client.responseType = "json";
                client.setRequestHeader("Accept", "application/json");
                client.send();

            });

            return promise;
        };

        getJSON("/posts.json").then(function (json) {
            console.log('Contents: ' + json);
        }, function (error) {
            console.error('出错了', error);
        });

        const p1 = new Promise(function (resolve, reject) {
        setTimeout(() => reject(new Error('fail')), 3000)
        })

        //注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。
        const p2 = new Promise(function (resolve, reject) {
        setTimeout(() => resolve(p1), 1000)
        })

        p2
        .then(result => console.log(result))
        .catch(error => console.log(error))//Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。
        // Error: fail

        new Promise((resolve, reject) => {
            resolve(1);
            console.log(2);
            }).then(r => {
            console.log(r);
            });
            // 2
            // 1
    </script>
</body>

</html>